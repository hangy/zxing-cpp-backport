name: Backport zxing-cpp (multi-arch + repo + release + auto-bpo)

on:
  workflow_dispatch:
    inputs:
      python_bindings:
        description: "Build Python bindings?"
        type: choice
        options: [on, off]
        default: on
      from_suite:
        description: "Source suite to pull from"
        type: choice
        options: [trixie, unstable]
        default: trixie
      sign_release:
        description: "Sign .dsc/.changes and APT repo?"
        type: choice
        options: [yes, no]
        default: yes
  push:
    tags:
      - "v*.*.*"     # Tag-Push triggert Release + Snapshots
    branches: [ main ]
    paths:
      - "debian/**"

permissions:
  contents: write
  pages: write
  id-token: write

env:
  PKG: zxing-cpp
  FROM_SUITE: ${{ inputs.from_suite || 'trixie' }}
  PYBIND: ${{ inputs.python_bindings || 'on' }}

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        suite: [bullseye, bookworm]
        arch: [amd64, arm64]
    env:
      BPO11: "~bpo11+"
      BPO12: "~bpo12+"
    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup QEMU for cross-arch
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Install host prereqs
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            debian-archive-keyring devscripts equivs git ca-certificates \
            sbuild mmdebstrap debhelper dpkg-dev fakeroot eatmydata quilt \
            gnupg dput reprepro \
            qemu-user-static binfmt-support

      - name: Prepare sbuild user & dirs
        run: |
          sudo adduser --quiet --disabled-password --gecos '' sbuild || true
          sudo adduser $USER sbuild || true
          sudo mkdir -p /var/lib/sbuild
          sudo chown -R sbuild:sbuild /var/lib/sbuild

      - name: Create chroot (mmdebstrap + unshare)
        env:
          SUITE: ${{ matrix.suite }}
          ARCH: ${{ matrix.arch }}
        run: |
          sudo sbuild-createchroot --include=eatmydata,ccache,qemu-user-static \
            --arch="$ARCH" --chroot-mode=unshare \
            "$SUITE" "/var/lib/sbuild/${SUITE}-${ARCH}" http://deb.debian.org/debian

      - name: Fetch source from ${{ env.FROM_SUITE }}
        run: |
          echo "deb-src http://deb.debian.org/debian ${FROM_SUITE} main" | sudo tee /etc/apt/sources.list.d/from-src.list
          sudo apt-get update
          apt source -t "${FROM_SUITE}" "${PKG}"
          sudo rm /etc/apt/sources.list.d/from-src.list
          sudo apt-get update

      - name: Apply backport version (auto-increment) & toggles
        shell: bash
        run: |
          set -e
          SRC_DIR=$(echo ${PKG}-*)
          cd "$SRC_DIR"

          # Basisversion aus changelog der trixie/unstable-Quelle (ohne ~bpo*)
          BASE_VER=$(dpkg-parsechangelog -S Version | sed -E 's/~bpo(11|12)\+[0-9]+$//')

          case "${{ matrix.suite }}" in
            bullseye) BPO="${BPO11}"; SUITE_TAG="bullseye";;
            bookworm) BPO="${BPO12}"; SUITE_TAG="bookworm";;
            *) echo "Unsupported suite"; exit 1;;
          esac

          # Höchsten X aus Tags backport/<suite>/<BASE_VER>/<X> ermitteln
          EXISTING=$(git tag -l "backport/${SUITE_TAG}/${BASE_VER}/*" | sed -E 's#.*/([0-9]+)$#\1#' | sort -n | tail -n1)
          if [ -z "$EXISTING" ]; then
            NEXT=1
          else
            NEXT=$((EXISTING + 1))
          fi

          NEW_VER="${BASE_VER}${BPO}${NEXT}"
          echo "Using backport version: ${NEW_VER}"

          # Changelog setzen
          dch --newversion "${NEW_VER}" --distribution "${{ matrix.suite }}" \
              "Automated backport to ${{ matrix.suite }} (CI bump to ${NEW_VER})."

          # Optional: Python-Bindings deaktivieren
          if [ "${PYBIND}" = "off" ]; then
            echo 'export DEB_CMAKE_EXTRA_FLAGS += -DZXING_BUILD_PYTHON=OFF' >> debian/rules
            dch -a "CI: disable Python bindings for ${{ matrix.suite }} build."
          fi

          debian/rules clean || true

      - name: Build source package (.dsc)
        run: |
          SRC_DIR=$(echo ${PKG}-*)
          cd "$SRC_DIR"
          dpkg-buildpackage -S -us -uc

      - name: sbuild (clean chroot build)
        env:
          SUITE: ${{ matrix.suite }}
          ARCH: ${{ matrix.arch }}
        run: |
          DSC=(./${PKG}_*~bpo*.dsc)
          if [ ! -e "${DSC[0]}" ]; then
            DSC=(./${PKG}_*.dsc)
          fi
          sbuild --arch="${ARCH}" --dist="${SUITE}" --chroot-mode=unshare "${DSC[0]}"

      - name: Import GPG key (optional)
        if: ${{ (inputs.sign_release == 'yes') || (github.event.inputs.sign_release == null && secrets.GPG_PRIVATE_KEY != '') }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          [ -n "$GPG_PRIVATE_KEY" ] || { echo "No GPG key provided, skipping import"; exit 0; }
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --reload gpg-agent

      - name: Debsign artifacts (optional)
        if: ${{ (inputs.sign_release == 'yes') || (github.event.inputs.sign_release == null && secrets.GPG_PRIVATE_KEY != '') }}
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GPG_KEYID: ${{ secrets.GPG_KEYID }}
        run: |
          set -e
          CHG=(./${PKG}_*_${{ matrix.arch }}.changes)
          DSC=(./${PKG}_*.dsc)
          for f in "${CHG[@]}" "${DSC[@]}"; do
            [ -e "$f" ] || continue
            if [ -n "${GPG_KEYID}" ]; then
              debsign -k"${GPG_KEYID}" --re-sign --no-conf \
                -p"gpg --batch --yes --pinentry-mode loopback --passphrase '${GPG_PASSPHRASE}'" "$f"
            else
              debsign --re-sign --no-conf \
                -p"gpg --batch --yes --pinentry-mode loopback --passphrase '${GPG_PASSPHRASE}'" "$f"
            fi
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PKG }}-${{ matrix.suite }}-${{ matrix.arch }}-${{ github.sha }}
          path: |
            ./*.deb
            ./*.ddeb
            ./*.changes
            ./*.buildinfo
            ./*.dsc
            ./*.tar.*
          if-no-files-found: error

  repo:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./dist

      - name: Install reprepro & gpg
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends reprepro gnupg

      - name: Prepare signing key (optional)
        if: ${{ secrets.GPG_PRIVATE_KEY != '' }}
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpg --list-keys

      - name: Build APT repository (latest & snapshots)
        shell: bash
        run: |
          set -e
          REPO=repo
          mkdir -p "$REPO/conf"
          # Basiskonfiguration für "latest"-Suites
          cat > "$REPO/conf/distributions" <<'EOF'
Codename: bullseye
Components: main
Architectures: amd64 arm64 source
SignWith: default

Codename: bookworm
Components: main
Architectures: amd64 arm64 source
SignWith: default
EOF

          shopt -s nullglob
          # 1) Neueste Artefakte in die "latest"-Suites aufnehmen
          for suite in bullseye bookworm; do
            # Binärpakete
            for deb in dist/**/${PKG}_*_*\.deb; do
              case "$deb" in
                *-${suite}-*) reprepro -b "$REPO" includedeb "$suite" "$deb" || true ;;
              esac
            done
            # Debug-Pakete
            for ddeb in dist/**/${PKG}_*_*\.ddeb; do
              case "$ddeb" in
                *-${suite}-*) reprepro -b "$REPO" includedeb "$suite" "$ddeb" || true ;;
              esac
            done
            # Source-Pakete
            for dsc in dist/**/${PKG}_*.dsc; do
              case "$dsc" in
                *-${suite}-*) reprepro -b "$REPO" includedsc "$suite" "$dsc" || true ;;
              esac
            done
          done

          # 2) Snapshot-Suites bei Tag-Builds erzeugen und füllen
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"   # z.B. v1.2.3
            for suite in bullseye bookworm; do
              SNAP_SUITE="${suite}-${TAG}"

              # Distribution-Eintrag für Snapshot anlegen (falls noch nicht da)
              if ! grep -q "Codename: ${SNAP_SUITE}" "$REPO/conf/distributions"; then
                cat >> "$REPO/conf/distributions" <<EOF
Codename: ${SNAP_SUITE}
Components: main
Architectures: amd64 arm64 source
SignWith: default
EOF
              fi

              # Pakete aus "latest" in Snapshot kopieren
              reprepro -b "$REPO" createsymlinks
              for pkg in ${PKG} ${PKG}-tools libzxing3 libzxing-dev python3-zxing-cpp; do
                reprepro -b "$REPO" copypackages "$SNAP_SUITE" "$suite" "$pkg" || true
                reprepro -b "$REPO" copysrc      "$SNAP_SUITE" "$suite" "$pkg" || true
              done
            done
          fi

          # Öffentlichen Schlüssel exportieren
          mkdir -p "$REPO/keys"
          gpg --batch --export -a > "$REPO/keys/repo.asc" || true

          # Tarball fürs Release
          tar -C "$REPO" -czf repo.tar.gz .
        env:
          PKG: zxing-cpp

      - name: Upload APT repo artifact
        uses: actions/upload-artifact@v4
        with:
          name: apt-repo
          path: |
            repo/**
            repo.tar.gz
          if-no-files-found: error

      - name: Upload repo for Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: repo

  deploy-pages:
    needs: repo
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  release:
    needs: [build, repo]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./dist

      - name: Collect files for release
        run: |
          mkdir out
          find dist -type f -name "*.deb" -exec cp -v {} out/ \;
          find dist -type f -name "*.ddeb" -exec cp -v {} out/ \;
          find dist -type f -name "*.changes" -exec cp -v {} out/ \;
          find dist -type f -name "*.buildinfo" -exec cp -v {} out/ \;
          find dist -type f -name "*.dsc" -exec cp -v {} out/ \;
          find dist -type f -name "*.tar.*" -exec cp -v {} out/ \;
          # APT-Repo-Tarball + Key
          if [ -f dist/apt-repo/repo.tar.gz ]; then
            cp -v dist/apt-repo/repo.tar.gz out/
          fi
          if [ -f dist/apt-repo/repo/keys/repo.asc ]; then
            cp -v dist/apt-repo/repo/keys/repo.asc out/
          fi

      - name: Create GitHub Release (draft)
        uses: softprops/action-gh-release@v2
        with:
          draft: true
          files: out/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag backport counters per suite
        shell: bash
        run: |
          set -e
          mapfile -t DSCS < <(find dist -type f -name "${PKG}_*.dsc")
          for dsc in "${DSCS[@]}"; do
            # Version aus Dateiname ziehen (robust)
            VER=$(basename "$dsc" | sed -E 's/.*_([^_]+)\.dsc/\1/')
            SUITE_TAG=""
            echo "$VER" | grep -q "~bpo11+" && SUITE_TAG="bullseye"
            echo "$VER" | grep -q "~bpo12+" && SUITE_TAG="bookworm"
            [ -n "$SUITE_TAG" ] || continue

            BASE=$(echo "$VER" | sed -E 's/~bpo(11|12)\+[0-9]+$//')
            X=$(echo "$VER"   | sed -nE 's/.*~bpo(11|12)\+([0-9]+)$/\2/p')
            [ -n "$BASE" ] && [ -n "$X" ] || continue

            TAG="backport/${SUITE_TAG}/${BASE}/${X}"
            if ! git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
              git tag -a "${TAG}" -m "Backport ${BASE} ${SUITE_TAG} ~bpo ${X}"
              git push origin "${TAG}"
            fi
          done
        env:
          PKG: zxing-cpp
